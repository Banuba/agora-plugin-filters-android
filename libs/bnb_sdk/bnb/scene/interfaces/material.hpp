/// \file
/// \addtogroup Scene
/// @{
///
// AUTOGENERATED FILE - DO NOT MODIFY!
// This file was generated by Djinni from scene.djinni

#pragma once

#include <bnb/utils/defs.hpp>
#include <memory>
#include <string>
#include <vector>

namespace bnb { namespace interfaces {

class image;
class parameter;
enum class geometry_topology;
struct shader_source;
struct state;

/**Class, represents material interface */
class BNB_EXPORT material {
public:
    virtual ~material() {}

    /**@return material name (string) */
    virtual std::string get_name() const = 0;

    /**
     *adds shader parameter to parameters list, after what you'll can get access to this parameter in shader by it's name. 
     *Type of parameter in shader will match with type of parameter, except int, float, vector2, vector3, 
     *this types will be replaces on vec4, which x component will have needed value, other components will be filled by garbage.
     *@param parameter (parameter): parameter to add
     */
    virtual void add_parameter(const std::shared_ptr<parameter> & parameter) = 0;

    /**@return list of shader parameters (list<parameter>) */
    virtual std::vector<std::shared_ptr<parameter>> get_parameters() const = 0;

    /**
     *removes parameter from list.
     *@param parameter (parameter): parameter to remove
     */
    virtual void remove_parameter(const std::shared_ptr<parameter> & parameter) = 0;

    /**
     *find parameter by name
     *@param name (string)
     *@return parameter (parameter) or null
     */
    virtual std::shared_ptr<parameter> find_parameter(const std::string & name) = 0;

    /**
     *set material geometry topology.
     *@param topology (geometry_topology): geometry topology type. Can be triangles_list, lines_list, points_list. Default: triangles_list
     */
    virtual void set_topology(geometry_topology topology) = 0;

    /**@return current geometry topology (geometry_topology) */
    virtual geometry_topology get_current_topology() const = 0;

    /**
     *sets render state (i.e blending mode, color/depth writing, depth testing, etc.)
     *@param state (state) render state
     */
    virtual void set_state(const state & state) = 0;

    /**@return render state (state) */
    virtual state get_state() const = 0;

    /**
     *add image sampler, after what you'll can get acess to image and sampler in shader by formula: image_index = i * 2. sampler_index = i * 2 + 1. 
     *Where i is image index in images list (which you can get by get_images call). 
     *Note that you need to declare images samplers in shader manually and sampler name in name must match with sampler name in material.
     *@param sampler (string): sampler name
     *@param image (image): sampler image
     */
    virtual void add_image(const std::string & sampler, const std::shared_ptr<image> & image) = 0;

    /**@return list of samplers images (list<parameter>) */
    virtual std::vector<std::shared_ptr<image>> get_images() const = 0;

    /**
     *removes image from list (if exist). Will be ignored if effect was activated.
     *@param sampler (string): sampler name
     */
    virtual void remove_image(const std::string & sampler) = 0;

    /**@return list of samplers name (list<string>) */
    virtual std::vector<std::string> get_samplers() const = 0;

    /**@return compiled and combined shaders sources */
    virtual shader_source get_shader_source() const = 0;
};

} }  // namespace bnb::interfaces
/// @}

